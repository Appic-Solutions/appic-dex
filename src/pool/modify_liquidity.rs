// Liquidity modification

use candid::Principal;
use ethnum::I256;

use crate::{
    libraries::{
        amount_delta::{get_amount_0_delta_signed, get_amount_1_delta_signed},
        balance_delta::BalanceDelta,
        constants::{MAX_TICK, MIN_TICK},
        tick_bitmap, tick_math,
    },
    position::{
        types::{PositionInfo, PositionKey},
        update_position, UpdatePsotionError,
    },
    state::read_state,
    tick::{
        get_fee_growth_inside, tick_spacing_to_max_liquidity_per_tick,
        types::{BitmapWord, TickBitmapKey, TickInfo, TickKey},
        update_tick,
    },
};

use super::types::{PoolId, PoolTickSpacing};

/// Keeps state changes, in case of success, state transition will be applied using this buffer
/// state, In case of failure no state transition will be triggered
#[derive(Clone, PartialEq, Eq, Default)]
pub struct ModifyLiquidityBufferState {
    tick_lower: Option<(TickKey, TickInfo)>,
    tick_upper: Option<(TickKey, TickInfo)>,
    flipped_lower_tick_bitmap: Option<(TickBitmapKey, BitmapWord)>,
    flipped_upper_tick_bitmap: Option<(TickBitmapKey, BitmapWord)>,
    postion: Option<(PositionKey, PositionInfo)>,
}

#[derive(Clone, PartialEq, Eq, Default)]
pub struct ModifyLiquidityState {
    flipped_lower: bool,
    liquidity_gross_after_lower: u128,
    flipped_upper: bool,
    liquidity_gross_after_upper: u128,
}

#[derive(Clone, PartialEq, Eq)]
pub struct ModifyLiquidityParams {
    // the address that owns the position
    pub owner: Principal,
    // the pool that position belongs to
    pub pool_id: PoolId,
    // the lower and upper tick of the position
    pub tick_lower: i32,
    pub tick_upper: i32,
    // any change in liquidity
    pub liquidity_delta: i128,
    // the spacing between ticks
    pub tick_spacing: PoolTickSpacing,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]
pub enum ModifyLiquidityError {
    InvalidTick,
    TickNotAligendWithTickSpacing,
    PoolNotInitialized,
    LiquidityOverflow,
    TickLiquidityOverflow,
    ZeroLiquidityPosition,
    PositionOverflow,
    FeeOwedOverflow,
    AmountDeltaOverflow,
}

#[derive(Clone, PartialEq, Eq)]
pub struct ModifyLiquiditySuccess {
    balalnce_delta: BalanceDelta,
    fee_delta: BalanceDelta,
    buffer_state: ModifyLiquidityBufferState,
}

/// Effects changes to a position in a pool, updating its liquidity and calculating resulting token balance changes and fees.
///
/// # Arguments
/// * `params` - The position details and the change to the position's liquidity to effect.
///
/// # Returns
/// *  `delta, fee_delta, modify_liquidity_buffer_state`
///   - `delta`: The `BalanceDelta` representing the changes to the pool's token balances due to the liquidity change.
///   - `fee_delta`: The `U256` amount of fees generated by the liquidity range.
/// * `Err(PositionError)` - If the operation fails (e.g., invalid position or uninitialized pool).
///
/// # Notes
/// - Assumes the pool is initialized, as verified by the `PoolManager` before calling this function.
pub fn modify_liquidity(
    params: ModifyLiquidityParams,
) -> Result<ModifyLiquiditySuccess, ModifyLiquidityError> {
    let liquidity_delta = params.liquidity_delta;
    let tick_lower = params.tick_lower;
    let tick_upper = params.tick_upper;

    if tick_lower >= tick_upper || tick_lower < MIN_TICK || tick_upper > MAX_TICK {
        return Err(ModifyLiquidityError::InvalidTick);
    };

    let pool = read_state(|s| s.get_pool(&params.pool_id))
        .ok_or(ModifyLiquidityError::PoolNotInitialized)?;

    let tick_current = pool.tick;
    let fee_growth_global_0_x128 = pool.fee_growth_global_0_x128;
    let fee_growth_global_1_x128 = pool.fee_growth_global_1_x128;

    let tick_lower_key = TickKey {
        pool_id: params.pool_id.clone(),
        tick: tick_lower,
    };

    let tick_upper_key = TickKey {
        pool_id: params.pool_id.clone(),
        tick: tick_upper,
    };

    let tick_current_key = TickKey {
        pool_id: params.pool_id.clone(),
        tick: tick_current,
    };

    let tick_spacing = params.tick_spacing.0;

    let mut modifiy_liquidity_state = ModifyLiquidityState::default();
    let mut buffer_state = ModifyLiquidityBufferState::default();

    // add current ticks to buffer state
    buffer_state.tick_lower = Some((
        tick_lower_key.clone(),
        read_state(|s| s.get_tick(&tick_lower_key)),
    ));
    buffer_state.tick_upper = Some((
        tick_upper_key.clone(),
        read_state(|s| s.get_tick(&tick_upper_key)),
    ));

    // if we need to update the ticks, do it
    if liquidity_delta != 0 {
        let updated_tick_lower = update_tick(
            &tick_lower_key,
            &tick_current_key,
            liquidity_delta,
            pool.fee_growth_global_0_x128,
            pool.fee_growth_global_1_x128,
            false,
        )
        .map_err(|_e| ModifyLiquidityError::LiquidityOverflow)?;

        modifiy_liquidity_state.liquidity_gross_after_lower =
            updated_tick_lower.liquidity_gross_after;

        let updated_tick_upper = update_tick(
            &tick_upper_key,
            &tick_current_key,
            liquidity_delta,
            pool.fee_growth_global_0_x128,
            pool.fee_growth_global_1_x128,
            true,
        )
        .map_err(|_e| ModifyLiquidityError::LiquidityOverflow)?;

        modifiy_liquidity_state.liquidity_gross_after_upper =
            updated_tick_upper.liquidity_gross_after;

        // Ceck liquidity growth after
        if liquidity_delta > 0 {
            if updated_tick_lower.liquidity_gross_after
                > tick_spacing_to_max_liquidity_per_tick(tick_spacing)
                || updated_tick_upper.liquidity_gross_after
                    > tick_spacing_to_max_liquidity_per_tick(tick_spacing)
            {
                return Err(ModifyLiquidityError::TickLiquidityOverflow);
            }
        }

        if updated_tick_lower.flipped {
            let flipped_info = tick_bitmap::flip_tick(&tick_lower_key, tick_spacing)
                .map_err(|_e| ModifyLiquidityError::TickNotAligendWithTickSpacing)?;
            // update buffer state
            buffer_state.flipped_lower_tick_bitmap =
                Some((flipped_info.bitmap_key, flipped_info.flipped_bitmap_word));
            // modifiy liquidity state update
            modifiy_liquidity_state.flipped_lower = true
        }

        if updated_tick_upper.flipped {
            let flipped_info = tick_bitmap::flip_tick(&tick_lower_key, tick_spacing)
                .map_err(|_e| ModifyLiquidityError::TickNotAligendWithTickSpacing)?;
            // update buffer state
            buffer_state.flipped_upper_tick_bitmap =
                Some((flipped_info.bitmap_key, flipped_info.flipped_bitmap_word));
            // modifiy liquidity state update
            modifiy_liquidity_state.flipped_upper = true
        }

        // update buffer state based on changes
        buffer_state.tick_lower =
            Some((tick_lower_key.clone(), updated_tick_lower.updated_tick_info));
        buffer_state.tick_upper =
            Some((tick_upper_key.clone(), updated_tick_upper.updated_tick_info));
    }

    // Calculate fees owed + update position if needed
    let (fee_growth_inside_0_x128, fee_growth_inside_1_x128) = get_fee_growth_inside(
        &tick_lower_key,
        &tick_upper_key,
        &buffer_state
            .tick_lower
            .clone()
            .expect("Bug: Tick should be populated")
            .1,
        &buffer_state
            .tick_upper
            .clone()
            .expect("Bug: Tick should be populated")
            .1,
        &tick_current_key,
        fee_growth_global_0_x128,
        fee_growth_global_1_x128,
    );
    let position_key = PositionKey {
        owner: params.owner,
        pool_id: params.pool_id,
        tick_lower,
        tick_upper,
    };

    let updated_position = update_position(
        &position_key,
        liquidity_delta,
        fee_growth_inside_0_x128,
        fee_growth_inside_1_x128,
    )
    .map_err(|e| match e {
        UpdatePsotionError::ZeropLiquidity => ModifyLiquidityError::ZeroLiquidityPosition,
        UpdatePsotionError::AddDeltaError(_add_delta_error) => {
            ModifyLiquidityError::PositionOverflow
        }
        UpdatePsotionError::MathError(_full_math_error) => ModifyLiquidityError::PositionOverflow,
    })?;

    // update buffer state with new position info
    buffer_state.postion = Some((position_key, updated_position.updated_position_info));

    let fee_delta = BalanceDelta::new(
        updated_position
            .fee0_owed
            .try_into()
            .map_err(|_e| ModifyLiquidityError::FeeOwedOverflow)?,
        updated_position
            .fee1_owed
            .try_into()
            .map_err(|_e| ModifyLiquidityError::FeeOwedOverflow)?,
    );

    // clear any tick data that is no longer needed
    if liquidity_delta < 0 {
        if modifiy_liquidity_state.flipped_lower {
            buffer_state.tick_lower = Some((tick_lower_key, TickInfo::default()));
        }
        if modifiy_liquidity_state.flipped_upper {
            buffer_state.tick_upper = Some((tick_upper_key, TickInfo::default()));
        }
    }

    let sqrt_price_a_x96 = tick_math::TickMath::get_sqrt_ratio_at_tick(tick_lower);
    let sqrt_price_b_x96 = tick_math::TickMath::get_sqrt_ratio_at_tick(tick_upper);

    // calculate amount deltas
    let mut balalnce_delta = BalanceDelta::ZERO_DELTA;
    if liquidity_delta != 0 {
        if tick_current < tick_lower {
            // current tick is below the passed range; liquidity can only become in range by crossing from left to
            // right, when we'll need _more_ currency0 (it's becoming more valuable) so user must provide it
            let amount0_delta =
                get_amount_0_delta_signed(sqrt_price_a_x96, sqrt_price_b_x96, liquidity_delta)
                    .map_err(|_e| ModifyLiquidityError::AmountDeltaOverflow)?;

            balalnce_delta = BalanceDelta::new(amount0_delta, I256::ZERO);
        } else if tick_current < tick_upper {
            let amount0_delta =
                get_amount_0_delta_signed(sqrt_price_a_x96, sqrt_price_b_x96, liquidity_delta)
                    .map_err(|_e| ModifyLiquidityError::AmountDeltaOverflow)?;

            let amount1_delta =
                get_amount_1_delta_signed(sqrt_price_a_x96, sqrt_price_b_x96, liquidity_delta)
                    .map_err(|_e| ModifyLiquidityError::AmountDeltaOverflow)?;

            balalnce_delta = BalanceDelta::new(amount0_delta, amount1_delta);
        } else {
            // current tick is above the passed range; liquidity can only become in range by crossing from right to
            // left, when we'll need _more_ currency1 (it's becoming more valuable) so user must provide it

            let amount1_delta =
                get_amount_1_delta_signed(sqrt_price_a_x96, sqrt_price_b_x96, liquidity_delta)
                    .map_err(|_e| ModifyLiquidityError::AmountDeltaOverflow)?;

            balalnce_delta = BalanceDelta::new(I256::ZERO, amount1_delta);
        }
    };

    Ok(ModifyLiquiditySuccess {
        balalnce_delta,
        fee_delta,
        buffer_state,
    })
}
