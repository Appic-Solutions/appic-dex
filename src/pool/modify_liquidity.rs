// Liquidity modification

use candid::Principal;
use ethnum::{I256, U256};

use crate::{
    libraries::{
        amount_delta::{get_amount_0_delta_signed, get_amount_1_delta_signed},
        balance_delta::BalanceDelta,
        constants::{MAX_TICK, MIN_TICK},
        liquidity_math::add_delta,
        tick_bitmap::{self, TickBitmapError},
        tick_math::TickMath,
    },
    position::{
        types::{PositionInfo, PositionKey},
        update_position, UpdatePsotionError,
    },
    state::read_state,
    tick::{
        get_fee_growth_inside, tick_spacing_to_max_liquidity_per_tick,
        types::{BitmapWord, TickBitmapKey, TickInfo, TickKey},
        update_tick,
    },
};

use super::types::{PoolId, PoolState, PoolTickSpacing};

/// Keeps state changes, in case of success, state transition will be applied using this buffer
/// state, In case of failure no state transition will be triggered
/// Buffer for state changes to apply only on successful modification.
#[derive(Clone, PartialEq, Eq, Debug)]
pub struct ModifyLiquidityBufferState {
    pub tick_lower: (TickKey, TickInfo),
    pub tick_upper: (TickKey, TickInfo),
    pub pool: (PoolId, PoolState),
    pub flipped_lower_tick_bitmap: Option<(TickBitmapKey, BitmapWord)>,
    pub flipped_upper_tick_bitmap: Option<(TickBitmapKey, BitmapWord)>,
    pub position: Option<(PositionKey, PositionInfo)>,
}

#[derive(Clone, PartialEq, Eq, Default)]
pub struct ModifyLiquidityState {
    flipped_lower: bool,
    liquidity_gross_after_lower: u128,
    flipped_upper: bool,
    liquidity_gross_after_upper: u128,
}

#[derive(Clone, PartialEq, Eq)]
pub struct ModifyLiquidityParams {
    // the address that owns the position
    pub owner: Principal,
    // the pool that position belongs to
    pub pool_id: PoolId,
    // the lower and upper tick of the position
    pub tick_lower: i32,
    pub tick_upper: i32,
    // any change in liquidity
    pub liquidity_delta: i128,
    // the spacing between ticks
    pub tick_spacing: PoolTickSpacing,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Debug)]
pub enum ModifyLiquidityError {
    InvalidTick,
    TickNotAlignedWithTickSpacing,
    PoolNotInitialized,
    LiquidityOverflow,
    TickLiquidityOverflow,
    ZeroLiquidityPosition,
    PositionOverflow,
    FeeOwedOverflow,
    AmountDeltaOverflow,
    InvalidTickSpacing,
}

#[derive(Clone, PartialEq, Eq, Debug)]
pub struct ModifyLiquiditySuccess {
    pub balance_delta: BalanceDelta,
    pub fee_delta: BalanceDelta,
    pub buffer_state: ModifyLiquidityBufferState,
}

/// Effects changes to a position in a pool, updating its liquidity and calculating resulting token balance changes and fees.
///
/// # Arguments
/// * `params` - The position details and the change to the position's liquidity to effect.
///
/// # Returns
/// *  `delta, fee_delta, modify_liquidity_buffer_state`
///   - `delta`: The `BalanceDelta` representing the changes to the pool's token balances due to the liquidity change.
///   - `fee_delta`: The `U256` amount of fees generated by the liquidity range.
/// * `Err(PositionError)` - If the operation fails (e.g., invalid position or uninitialized pool).
///
/// # Notes
/// - Assumes the pool is initialized, as verified by the `PoolManager` before calling this function.
pub fn modify_liquidity(
    params: ModifyLiquidityParams,
) -> Result<ModifyLiquiditySuccess, ModifyLiquidityError> {
    // Validate inputs
    validate_inputs(&params)?;

    // Fetch pool and tick data in a single state read
    let (pool, tick_lower_info, tick_upper_info) = read_state(|s| {
        (
            s.get_pool(&params.pool_id),
            s.get_tick(&TickKey {
                pool_id: params.pool_id.clone(),
                tick: params.tick_lower,
            }),
            s.get_tick(&TickKey {
                pool_id: params.pool_id.clone(),
                tick: params.tick_upper,
            }),
        )
    });

    let pool = pool.ok_or(ModifyLiquidityError::PoolNotInitialized)?;
    let tick_spacing = params.tick_spacing.0;

    // Initialize buffer state with current tick info
    let mut buffer_state = ModifyLiquidityBufferState {
        tick_lower: (
            TickKey {
                pool_id: params.pool_id.clone(),
                tick: params.tick_lower,
            },
            tick_lower_info,
        ),
        tick_upper: (
            TickKey {
                pool_id: params.pool_id.clone(),
                tick: params.tick_upper,
            },
            tick_upper_info,
        ),
        pool: (params.pool_id.clone(), pool.clone()),
        flipped_lower_tick_bitmap: None,
        flipped_upper_tick_bitmap: None,
        position: None,
    };

    let mut modify_state = ModifyLiquidityState::default();

    // Update ticks if liquidity changes
    if params.liquidity_delta != 0 {
        update_ticks(
            &params,
            &pool,
            &mut buffer_state,
            &mut modify_state,
            tick_spacing,
        )?;
    }

    // Calculate fees and update position
    let fee_delta = update_position_and_fees(
        &params,
        &mut buffer_state,
        pool.fee_growth_global_0_x128,
        pool.fee_growth_global_1_x128,
        pool.tick,
    )?;

    // Clear tick data if liquidity is removed
    if params.liquidity_delta < 0 {
        if modify_state.flipped_lower {
            buffer_state.tick_lower.1 = TickInfo::default();
        }
        if modify_state.flipped_upper {
            buffer_state.tick_upper.1 = TickInfo::default();
        }
    }

    // Calculate balance delta based on tick range
    let balance_delta = calculate_balance_delta_and_update_pool_liquidty(
        &params,
        &mut buffer_state,
        params.tick_lower,
        params.tick_upper,
        params.liquidity_delta,
        pool.tick,
    )?;

    Ok(ModifyLiquiditySuccess {
        balance_delta,
        fee_delta,
        buffer_state,
    })
}

/// Validates input parameters for liquidity modification.
fn validate_inputs(params: &ModifyLiquidityParams) -> Result<(), ModifyLiquidityError> {
    if params.tick_lower >= params.tick_upper
        || params.tick_lower < MIN_TICK
        || params.tick_upper > MAX_TICK
    {
        return Err(ModifyLiquidityError::InvalidTick);
    }
    if params.tick_spacing.0 <= 0 {
        return Err(ModifyLiquidityError::InvalidTickSpacing);
    }
    if params.tick_lower % params.tick_spacing.0 != 0
        || params.tick_upper % params.tick_spacing.0 != 0
    {
        return Err(ModifyLiquidityError::TickNotAlignedWithTickSpacing);
    }
    Ok(())
}

/// Updates tick states and bitmap for non-zero liquidity changes.
fn update_ticks(
    params: &ModifyLiquidityParams,
    pool: &PoolState,
    buffer_state: &mut ModifyLiquidityBufferState,
    modify_state: &mut ModifyLiquidityState,
    tick_spacing: i32,
) -> Result<(), ModifyLiquidityError> {
    let tick_current_key = TickKey {
        pool_id: params.pool_id.clone(),
        tick: pool.tick,
    };

    // Update lower tick
    let updated_lower = update_tick(
        &buffer_state.tick_lower.0,
        &tick_current_key,
        params.liquidity_delta,
        pool.fee_growth_global_0_x128,
        pool.fee_growth_global_1_x128,
        false,
    )
    .map_err(|_e| ModifyLiquidityError::LiquidityOverflow)?;

    modify_state.liquidity_gross_after_lower = updated_lower.liquidity_gross_after;
    buffer_state.tick_lower.1 = updated_lower.updated_tick_info;

    // Update upper tick
    let updated_upper = update_tick(
        &buffer_state.tick_upper.0,
        &tick_current_key,
        params.liquidity_delta,
        pool.fee_growth_global_0_x128,
        pool.fee_growth_global_1_x128,
        true,
    )
    .map_err(|_e| ModifyLiquidityError::LiquidityOverflow)?;

    modify_state.liquidity_gross_after_upper = updated_upper.liquidity_gross_after;
    buffer_state.tick_upper.1 = updated_upper.updated_tick_info;

    // Check liquidity limits for positive delta
    if params.liquidity_delta > 0 {
        let max_liquidity = tick_spacing_to_max_liquidity_per_tick(tick_spacing);
        if updated_lower.liquidity_gross_after > max_liquidity
            || updated_upper.liquidity_gross_after > max_liquidity
        {
            return Err(ModifyLiquidityError::TickLiquidityOverflow);
        }
    }

    // Flip tick bitmaps if needed
    if updated_lower.flipped {
        let flipped_info = tick_bitmap::flip_tick(&buffer_state.tick_lower.0, tick_spacing)
            .map_err(|e| match e {
                TickBitmapError::TickMisaligned(_, _) => {
                    ModifyLiquidityError::TickNotAlignedWithTickSpacing
                }
            })?;
        buffer_state.flipped_lower_tick_bitmap =
            Some((flipped_info.bitmap_key, flipped_info.flipped_bitmap_word));
        modify_state.flipped_lower = true;
    }

    if updated_upper.flipped {
        let flipped_info = tick_bitmap::flip_tick(&buffer_state.tick_upper.0, tick_spacing)
            .map_err(|e| match e {
                TickBitmapError::TickMisaligned(_, _) => {
                    ModifyLiquidityError::TickNotAlignedWithTickSpacing
                }
            })?;
        buffer_state.flipped_upper_tick_bitmap =
            Some((flipped_info.bitmap_key, flipped_info.flipped_bitmap_word));
        modify_state.flipped_upper = true;
    }

    Ok(())
}

/// Updates position and calculates fees owed.
fn update_position_and_fees(
    params: &ModifyLiquidityParams,
    buffer_state: &mut ModifyLiquidityBufferState,
    fee_growth_global_0_x128: U256,
    fee_growth_global_1_x128: U256,
    tick_current: i32,
) -> Result<BalanceDelta, ModifyLiquidityError> {
    // Calculate fee growth inside the range
    let (fee_growth_inside_0_x128, fee_growth_inside_1_x128) = get_fee_growth_inside(
        &buffer_state.tick_lower.0,
        &buffer_state.tick_upper.0,
        &buffer_state.tick_lower.1,
        &buffer_state.tick_upper.1,
        &TickKey {
            pool_id: params.pool_id.clone(),
            tick: tick_current,
        },
        fee_growth_global_0_x128,
        fee_growth_global_1_x128,
    );

    // Update position
    let position_key = PositionKey {
        owner: params.owner,
        pool_id: params.pool_id.clone(),
        tick_lower: params.tick_lower,
        tick_upper: params.tick_upper,
    };

    let updated_position = update_position(
        &position_key,
        params.liquidity_delta,
        fee_growth_inside_0_x128,
        fee_growth_inside_1_x128,
    )
    .map_err(|e| match e {
        UpdatePsotionError::ZeropLiquidity => ModifyLiquidityError::ZeroLiquidityPosition,
        UpdatePsotionError::AddDeltaError(_) => ModifyLiquidityError::PositionOverflow,
        UpdatePsotionError::MathError(_) => ModifyLiquidityError::PositionOverflow,
    })?;

    // Store updated position in buffer
    buffer_state.position = Some((position_key, updated_position.updated_position_info));

    // Calculate fee delta
    Ok(BalanceDelta::new(
        updated_position
            .fee0_owed
            .try_into()
            .map_err(|_| ModifyLiquidityError::FeeOwedOverflow)?,
        updated_position
            .fee1_owed
            .try_into()
            .map_err(|_| ModifyLiquidityError::FeeOwedOverflow)?,
    ))
}

/// Calculates balance delta based on the current tick and position range.
fn calculate_balance_delta_and_update_pool_liquidty(
    params: &ModifyLiquidityParams,
    buffer_state: &mut ModifyLiquidityBufferState,
    tick_lower: i32,
    tick_upper: i32,
    liquidity_delta: i128,
    tick_current: i32,
) -> Result<BalanceDelta, ModifyLiquidityError> {
    if liquidity_delta == 0 {
        return Ok(BalanceDelta::ZERO_DELTA);
    }

    let sqrt_price_a_x96 = TickMath::get_sqrt_ratio_at_tick(tick_lower);
    let sqrt_price_b_x96 = TickMath::get_sqrt_ratio_at_tick(tick_upper);

    if tick_current < tick_lower {
        // Below range: only token0 is needed
        let amount0_delta =
            get_amount_0_delta_signed(sqrt_price_a_x96, sqrt_price_b_x96, liquidity_delta)
                .map_err(|_| ModifyLiquidityError::AmountDeltaOverflow)?;
        Ok(BalanceDelta::new(amount0_delta, I256::ZERO))
    } else if tick_current < tick_upper {
        // In range: both tokens needed
        let amount0_delta =
            get_amount_0_delta_signed(sqrt_price_a_x96, sqrt_price_b_x96, liquidity_delta)
                .map_err(|_| ModifyLiquidityError::AmountDeltaOverflow)?;
        let amount1_delta =
            get_amount_1_delta_signed(sqrt_price_a_x96, sqrt_price_b_x96, liquidity_delta)
                .map_err(|_| ModifyLiquidityError::AmountDeltaOverflow)?;

        // Add liquidty delta to pool state
        let pool_liquidity = buffer_state.pool.1.liquidity;
        buffer_state.pool.1.liquidity = add_delta(pool_liquidity, params.liquidity_delta)
            .map_err(|_e| ModifyLiquidityError::AmountDeltaOverflow)?;

        Ok(BalanceDelta::new(amount0_delta, amount1_delta))
    } else {
        // Above range: only token1 is needed
        let amount1_delta =
            get_amount_1_delta_signed(sqrt_price_a_x96, sqrt_price_b_x96, liquidity_delta)
                .map_err(|_| ModifyLiquidityError::AmountDeltaOverflow)?;
        Ok(BalanceDelta::new(I256::ZERO, amount1_delta))
    }
}
