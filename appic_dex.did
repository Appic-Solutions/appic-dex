type BurnPositionArgs = record {
  amount1_min : nat;
  pool : CandidPoolId;
  amount0_min : nat;
  tick_lower : int;
  tick_upper : int;
};
type BurnPositionError = variant {
  PositionNotFound;
  InvalidAmount;
  InvalidPoolFee;
  PoolNotInitialized;
  InsufficientBalance;
  LiquidityOverflow;
  FeeOverflow;
  BurntPositionWithdrawalFailed : WithdrawalError;
  InvalidTick;
  LockedPrincipal;
  AmountOverflow;
};
type CandidPathKey = record { fee : nat; intermediary_token : principal };
type CandidPoolId = record {
  fee : nat;
  token0 : principal;
  token1 : principal;
};
type CandidPoolState = record {
  sqrt_price_x96 : nat;
  pool_reserves0 : nat;
  pool_reserves1 : nat;
  fee_protocol : nat;
  token0_transfer_fee : nat;
  swap_volume1_all_time : nat;
  fee_growth_global_1_x128 : nat;
  tick : int;
  liquidity : nat;
  generated_swap_fee0 : nat;
  generated_swap_fee1 : nat;
  swap_volume0_all_time : nat;
  fee_growth_global_0_x128 : nat;
  max_liquidity_per_tick : nat;
  token1_transfer_fee : nat;
  tick_spacing : int;
};
type CandidPositionInfo = record {
  fees_token0_owed : nat;
  fee_growth_inside_1_last_x128 : nat;
  liquidity : nat;
  fees_token1_owed : nat;
  fee_growth_inside_0_last_x128 : nat;
};
type CandidPositionKey = record {
  owner : principal;
  pool : CandidPoolId;
  tick_lower : int;
  tick_upper : int;
};
type CandidSwapSuccess = record { amount_out : nat; amount_in : nat };
type CollectFeesError = variant {
  PositionNotFound;
  FeeOverflow;
  LockedPrincipal;
  CollectedFeesWithdrawalFailed : WithdrawalError;
  NoFeeToCollect;
};
type CollectFeesSuccess = record {
  token0_collected : nat;
  token1_collected : nat;
};
type CreatePoolArgs = record {
  fee : nat;
  sqrt_price_x96 : nat;
  token_a : principal;
  token_b : principal;
};
type CreatePoolError = variant {
  InvalidSqrtPriceX96;
  InvalidFeeAmount;
  InvalidToken : principal;
  PoolAlreadyExists;
};
type DecreaseLiquidityArgs = record {
  amount1_min : nat;
  pool : CandidPoolId;
  liquidity : nat;
  amount0_min : nat;
  tick_lower : int;
  tick_upper : int;
};
type DecreaseLiquidityError = variant {
  PositionNotFound;
  InvalidAmount;
  InvalidPoolFee;
  PoolNotInitialized;
  InsufficientBalance;
  LiquidityOverflow;
  FeeOverflow;
  InvalidTick;
  InvalidLiquidity;
  LockedPrincipal;
  AmountOverflow;
  DecreasedPositionWithdrawalFailed : WithdrawalError;
};
type DepositArgs = record {
  token : principal;
  from_subaccount : opt blob;
  amount : nat;
};
type DepositError = variant {
  TemporarilyUnavailable : text;
  InvalidDestination : text;
  InsufficientAllowance : record { allowance : nat };
  AmountTooLow : record { min_withdrawal_amount : nat };
  AmountOverflow;
  InsufficientFunds : record { balance : nat };
};
type ExactInputParams = record {
  token_in : principal;
  path : vec CandidPathKey;
  from_subaccount : opt blob;
  amount_out_minimum : nat;
  amount_in : nat;
};
type ExactInputSingleParams = record {
  zero_for_one : bool;
  from_subaccount : opt blob;
  amount_out_minimum : nat;
  amount_in : nat;
  pool_id : CandidPoolId;
};
type ExactOutputParams = record {
  amount_in_maximum : nat;
  path : vec CandidPathKey;
  from_subaccount : opt blob;
  amount_out : nat;
  token_out : principal;
};
type ExactOutputSingleParams = record {
  amount_in_maximum : nat;
  zero_for_one : bool;
  from_subaccount : opt blob;
  amount_out : nat;
  pool_id : CandidPoolId;
};
type IncreaseLiquidity = variant {
  DepositError : DepositError;
  TickNotAlignedWithTickSpacing;
  InvalidAmount;
  InvalidPoolFee;
  PoolNotInitialized;
  InsufficientBalance;
  LiquidityOverflow;
  FeeOverflow;
  InvalidTick;
  PositionDoesNotExist;
  LockedPrincipal;
  AmountOverflow;
};
type IncreaseLiquidityArgs = record {
  amount1_max : nat;
  pool : CandidPoolId;
  from_subaccount : opt blob;
  amount0_max : nat;
  tick_lower : int;
  tick_upper : int;
};
type MintPositionArgs = record {
  amount1_max : nat;
  pool : CandidPoolId;
  from_subaccount : opt blob;
  amount0_max : nat;
  tick_lower : int;
  tick_upper : int;
};
type MintPositionError = variant {
  DepositError : DepositError;
  TickNotAlignedWithTickSpacing;
  InvalidAmount;
  InvalidPoolFee;
  PoolNotInitialized;
  InsufficientBalance;
  LiquidityOverflow;
  FeeOverflow;
  PositionAlreadyExists;
  InvalidTick;
  LockedPrincipal;
  AmountOverflow;
};
type QuoteArgs = variant {
  QuoteExactOutput : QuoteExactParams;
  QuoteExactOutputSingleParams : QuoteExactSingleParams;
  QuoteExactInputParams : QuoteExactParams;
  QuoteExactInputSingleParams : QuoteExactSingleParams;
};
type QuoteError = variant {
  InvalidAmount;
  PoolNotInitialized;
  InvalidFee;
  PriceLimitOutOfBounds;
  InvalidPathLength;
  IlliquidPool;
  PriceLimitAlreadyExceeded;
  InvalidFeeForExactOutput;
  CalculationOverflow;
};
type QuoteExactParams = record {
  path : vec CandidPathKey;
  exact_token : principal;
  exact_amount : nat;
};
type QuoteExactSingleParams = record {
  zero_for_one : bool;
  pool_id : CandidPoolId;
  exact_amount : nat;
};
type Result = variant { Ok; Err : BurnPositionError };
type Result_1 = variant { Ok : CollectFeesSuccess; Err : CollectFeesError };
type Result_2 = variant { Ok : CandidPoolId; Err : CreatePoolError };
type Result_3 = variant { Ok; Err : DecreaseLiquidityError };
type Result_4 = variant { Ok; Err : DepositError };
type Result_5 = variant { Ok : nat; Err : IncreaseLiquidity };
type Result_6 = variant { Ok : nat; Err : MintPositionError };
type Result_7 = variant { Ok : nat; Err : QuoteError };
type Result_8 = variant { Ok : CandidSwapSuccess; Err : SwapError };
type SwapArgs = variant {
  ExactOutput : ExactOutputParams;
  ExactInput : ExactInputParams;
  ExactOutputSingle : ExactOutputSingleParams;
  ExactInputSingle : ExactInputSingleParams;
};
type SwapError = variant {
  FailedToWithdraw : record {
    amount_out : nat;
    amount_in : nat;
    reason : WithdrawalError;
  };
  InvalidAmountOut;
  DepositError : DepositError;
  InvalidAmountIn;
  InvalidAmountInMaximum;
  InvalidAmountOutMinimum;
  InvalidPoolFee;
  PoolNotInitialized;
  PathLengthTooSmall : record { minimum : nat8; received : nat8 };
  PathDuplicated;
  PathLengthTooBig : record { maximum : nat8; received : nat8 };
  LockedPrincipal;
  NoInRangeLiquidity;
  SwapFailedRefunded : record {
    refund_error : opt WithdrawalError;
    refund_amount : opt nat;
    failed_reason : SwapFailedReason;
  };
};
type SwapFailedReason = variant {
  TooMuchRequested;
  InvalidAmount;
  PoolNotInitialized;
  InsufficientBalance;
  PriceLimitOutOfBounds;
  BalanceOverflow;
  TooLittleReceived;
  NoInRangeLiquidity;
  PriceLimitAlreadyExceeded;
  InvalidFeeForExactOutput;
  CalculationOverflow;
};
type UserBalanceArgs = record { token : principal; user : principal };
type WithdrawalError = variant {
  FeeUnknown;
  TemporarilyUnavailable : text;
  InvalidDestination : text;
  InsufficientAllowance : record { allowance : nat };
  InsufficientBalance : record { balance : nat };
  AmountTooLow : record { min_withdrawal_amount : nat };
};
service : () -> {
  burn : (BurnPositionArgs) -> (Result);
  collect_fees : (CandidPositionKey) -> (Result_1);
  create_pool : (CreatePoolArgs) -> (Result_2);
  decrease_liquidity : (DecreaseLiquidityArgs) -> (Result_3);
  deposit : (DepositArgs) -> (Result_4);
  get_pool : (CandidPoolId) -> (opt CandidPoolState) query;
  get_pools : () -> (vec record { CandidPoolId; CandidPoolState }) query;
  get_position : (CandidPositionKey) -> (opt CandidPositionInfo) query;
  get_positions_by_owner : (principal) -> (
      vec record { CandidPositionKey; CandidPositionInfo },
    ) query;
  increase_liquidity : (IncreaseLiquidityArgs) -> (Result_5);
  mint_position : (MintPositionArgs) -> (Result_6);
  quote : (QuoteArgs) -> (Result_7) query;
  swap : (SwapArgs) -> (Result_8);
  user_balance : (UserBalanceArgs) -> (nat) query;
}
